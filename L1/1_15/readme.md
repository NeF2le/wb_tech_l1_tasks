```go
var justString string

func someFunc() {
  v := createHugeString(1 << 10)
  justString = v[:100]
}

func main() {
  someFunc()
}
```
Такой код может привести к утечке памяти. Срез строки, к которому приравнивается `justString` не копирует данные, а только меняет длину массива, и присваивает переменной указатель на него. Из-за этого в памяти так же хранится весь массив, и это при больших объемах данных может вызвать утечку памяти, потому что сборщик мусора не почистит то, на что есть указатели.

```go
var justString string

func someFunc() {
	v := createHugeString(1 << 10)
	justString = string([]byte(v[:100]))
}

func func main() {
    someFunc()
}
```
Этот код решает проблему. Создается новый буфер для нужных данных, а старый освобождается сборщиком мусора.

С переменной `justString` происходит вот что. Она становится строкой с длиной 100, но под капотом хранит указатель на массив — в изначальном примере на 1024 байт, в нашем случае на 100.  