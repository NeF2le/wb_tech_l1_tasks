# Адаптер


Представим, что в нашем проекте используется такой интерфейс логгера
```go
type Logger interface {
	Info(msg string) error
}
```

Мы хотим использовать какой-то сторонний логгер, который мы не можем изменять
```go
type ExternalLogger struct {}

func (e *ExternalLogger) Write(msg string) error {
	// some code
}
```

Чтобы подогнать `ExternalLogger` к нашему интерфейсу, напишем адаптер
```go
type ExternalLoggerAdapter struct {
	external *ExternalLogger
}

func (a *ExternalLoggerAdapter) Info(msg string) error {
	return a.external.Write(msg)
}
```

**Применимость паттерна:** в случае с логгером есть много библиотек, у которых разный набор (и мб название) методов, и чтобы легко переходить с одной либы на другую, нужны адаптеры. Например, в slog`е нет Fatal(), а в интерфейсе нашего логгера он есть — нужен адаптер.

**Плюсы:**
- Позволяет интегрировать legacy-код или сторонние библиотеки без изменения их исходников
- Если сторонний код изменится, правки касаются только адаптера
- Повышает уровень абстракции: клиент видит только ожидаемый интерфейс
- Упрощает замену одной внешней системы на другую
- Преобразование интерфейсов концентрируется в одном месте

**Минусы:**
- Появляется ещё один слой кода, который нужно поддерживать. Для простых проектов может быть избыточным
- Адаптер может маскировать важные функции или ограничения сторонней библиотеки
- Если приходится цеплять несколько адаптеров подряд, код может стать громоздким и трудным для отладки

